<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>For Jess - Safe Test</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', Tahoma, sans-serif; }
        #webgl-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; }
        #css2d-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 2; pointer-events: none; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100vw; height: 100vh;
            display: flex; justify-content: center; align-items: center; z-index: 10;
            background: #000000; transition: opacity 1.5s ease; 
        }
        
        button {
            padding: 20px 40px; font-size: 24px; font-weight: bold; background-color: #e63946;
            color: white; border: none; border-radius: 50px; cursor: pointer;
            box-shadow: 0 10px 20px rgba(230, 57, 70, 0.4); transition: transform 0.2s; pointer-events: auto;
        }
        button:hover { transform: scale(1.05); }

        .map-label {
            color: white; font-weight: bold; padding: 5px 10px; border-radius: 5px;
            font-size: 14px; text-shadow: 1px 1px 3px rgba(0,0,0,0.8); pointer-events: none;
            white-space: nowrap;
        }
        .label-start { background: rgba(255, 215, 0, 0.5); border: 2px solid gold; color: gold; }
        .label-end { background: rgba(255, 105, 180, 0.5); border: 2px solid hotpink; color: hotpink; }
        
        #instructions {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            color: white; font-size: 18px; display: none; z-index: 5; pointer-events: none;
            text-shadow: 1px 1px 2px black;
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/",
                "gsap": "https://unpkg.com/gsap@3.12.2/index.js"
            }
        }
    </script>
</head>
<body>

    <div id="ui-layer">
        <button id="startBtn">Enter Our World</button>
    </div>
    <div id="instructions">Click the right side of the book to turn pages</div>
    
    <div id="webgl-container"></div>
    <div id="css2d-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
        import gsap from 'gsap';

        // --- GLOBAL SETUP ---
        const container = document.getElementById('webgl-container');
        const cssContainer = document.getElementById('css2d-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000); // Starts black until button clicked
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 4.5, 7); 

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        const labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        cssContainer.appendChild(labelRenderer.domElement);

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
        dirLight.position.set(2, 8, 5);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // --- SCENE 1: THE 3D SIMPSONS ROOM ---
        const roomGroup = new THREE.Group();
        scene.add(roomGroup);

        const floor = new THREE.Mesh(new THREE.PlaneGeometry(30, 30), new THREE.MeshStandardMaterial({ color: 0x1da289 }));
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        roomGroup.add(floor);

        const wallMat = new THREE.MeshStandardMaterial({ color: 0xff91af }); 
        const backWall = new THREE.Mesh(new THREE.PlaneGeometry(30, 15), wallMat);
        backWall.position.set(0, 7.5, -8);
        backWall.receiveShadow = true;
        roomGroup.add(backWall);

        const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(30, 15), wallMat);
        leftWall.rotation.y = Math.PI / 2;
        leftWall.position.set(-12, 7.5, 0);
        leftWall.receiveShadow = true;
        roomGroup.add(leftWall);

        const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(30, 15), wallMat);
        rightWall.rotation.y = -Math.PI / 2;
        rightWall.position.set(12, 7.5, 0);
        rightWall.receiveShadow = true;
        roomGroup.add(rightWall);

        const rug = new THREE.Mesh(new THREE.CylinderGeometry(4, 4, 0.05, 32), new THREE.MeshStandardMaterial({ color: 0xc964af }));
        rug.scale.set(1, 1, 0.6); 
        rug.position.set(0, 0.02, -1);
        roomGroup.add(rug);

        const couchMat = new THREE.MeshStandardMaterial({ color: 0xd2691e });
        const couchSeat = new THREE.Mesh(new THREE.BoxGeometry(6, 1, 2.5), couchMat);
        couchSeat.position.set(0, 0.5, 2.5);
        couchSeat.castShadow = true;
        const couchBack = new THREE.Mesh(new THREE.BoxGeometry(6, 2, 0.5), couchMat);
        couchBack.position.set(0, 2, 3.5);
        couchBack.castShadow = true;
        roomGroup.add(couchSeat, couchBack);

        const table = new THREE.Mesh(new THREE.BoxGeometry(3, 1, 1.5), new THREE.MeshStandardMaterial({ color: 0xcd853f }));
        table.position.set(0, 0.5, -1.5);
        table.castShadow = true;
        roomGroup.add(table);

        const tvStand = new THREE.Mesh(new THREE.BoxGeometry(4, 1.5, 2), new THREE.MeshStandardMaterial({ color: 0x784c98 }));
        tvStand.position.set(0, 0.75, -5.5);
        tvStand.castShadow = true;
        roomGroup.add(tvStand);

        const tvBox = new THREE.Mesh(new THREE.BoxGeometry(3.5, 2.5, 1.5), new THREE.MeshStandardMaterial({ color: 0x8a929e }));
        tvBox.position.set(0, 2.75, -5.5);
        tvBox.castShadow = true;
        roomGroup.add(tvBox);

        const lampBase = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.2, 4), new THREE.MeshStandardMaterial({ color: 0x8a2be2 }));
        lampBase.position.set(-4.5, 2, -6);
        const lampShade = new THREE.Mesh(new THREE.ConeGeometry(0.8, 1, 16), new THREE.MeshStandardMaterial({ color: 0xff4500 }));
        lampShade.position.set(-4.5, 4.5, -6);
        roomGroup.add(lampBase, lampShade);

        const frame = new THREE.Mesh(new THREE.BoxGeometry(2, 1.5, 0.1), new THREE.MeshStandardMaterial({ color: 0xcd853f }));
        frame.position.set(0, 6, -7.9);
        const picture = new THREE.Mesh(new THREE.PlaneGeometry(1.8, 1.3), new THREE.MeshBasicMaterial({ color: 0x87ceeb }));
        picture.position.set(0, 6, -7.84);
        roomGroup.add(frame, picture);

        const remoteGroup = new THREE.Group();
        const remoteBody = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.05, 0.6), new THREE.MeshStandardMaterial({ color: 0x222222 }));
        const remoteBtn = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.03, 0.08), new THREE.MeshStandardMaterial({ color: 0xff0000 }));
        remoteBtn.position.set(0, 0.03, -0.2); 
        remoteGroup.add(remoteBody, remoteBtn);
        remoteGroup.position.set(0.5, 1.02, -1.5); 
        roomGroup.add(remoteGroup);

        const flickerCanvas = document.createElement('canvas');
        flickerCanvas.width = 512; flickerCanvas.height = 256;
        const flickerCtx = flickerCanvas.getContext('2d');
        const flickerTexture = new THREE.CanvasTexture(flickerCanvas);
        
        // Initial TV screen is off (black)
        flickerCtx.fillStyle = '#111111';
        flickerCtx.fillRect(0, 0, 512, 256);

        const tvScreen = new THREE.Mesh(new THREE.PlaneGeometry(3.2, 2.2), new THREE.MeshBasicMaterial({ map: flickerTexture }));
        tvScreen.position.set(0, 2.75, -4.74); 
        roomGroup.add(tvScreen);

        // --- SCENE 2: THE 3D CITY MAP ---
        const mapGroup = new THREE.Group();
        mapGroup.visible = false;
        scene.add(mapGroup);

        const mapFloor = new THREE.Mesh(new THREE.PlaneGeometry(80, 80), new THREE.MeshStandardMaterial({ color: 0x111111 }));
        mapFloor.rotation.x = -Math.PI / 2;
        mapFloor.receiveShadow = true;
        mapGroup.add(mapFloor);

        const cityGroup = new THREE.Group();
        const buildingGeo = new THREE.BoxGeometry(1, 1, 1);
        const buildingMat = new THREE.MeshStandardMaterial({ color: 0x2a3b4c, roughness: 0.8 });

        for (let i = 0; i < 300; i++) {
            const building = new THREE.Mesh(buildingGeo, buildingMat);
            building.castShadow = true;
            building.receiveShadow = true;
            
            const x = (Math.random() - 0.5) * 50;
            const z = (Math.random() - 0.5) * 50;
            const height = Math.random() * 8 + 1;
            building.scale.set(1 + Math.random(), height, 1 + Math.random());
            building.position.set(x, height / 2, z);

            if (Math.abs(x - z) > 5) cityGroup.add(building);
        }
        mapGroup.add(cityGroup);

        const startPos = new THREE.Vector3(-12, 0.5, -12);
        const endPos = new THREE.Vector3(14, 0.5, 14);

        const startMarker = new THREE.Mesh(new THREE.SphereGeometry(0.8), new THREE.MeshBasicMaterial({ color: 0xffd700 }));
        startMarker.position.copy(startPos);
        mapGroup.add(startMarker);
        const startDiv = document.createElement('div'); startDiv.className = 'map-label label-start'; startDiv.textContent = '10996 Rametsane';
        startMarker.add(new CSS2DObject(startDiv));

        const endMarker = new THREE.Mesh(new THREE.SphereGeometry(0.8), new THREE.MeshBasicMaterial({ color: 0xff69b4 }));
        endMarker.position.copy(endPos);
        mapGroup.add(endMarker);
        const endDiv = document.createElement('div'); endDiv.className = 'map-label label-end'; endDiv.textContent = '59866 Shorobe St, Block 7';
        endMarker.add(new CSS2DObject(endDiv));

        const routeCurve = new THREE.CatmullRomCurve3([
            startPos, new THREE.Vector3(-6, 0.5, -4), new THREE.Vector3(2, 0.5, 0), new THREE.Vector3(8, 0.5, 6), endPos
        ]);
        const routeLine = new THREE.Line(
            new THREE.BufferGeometry().setFromPoints(routeCurve.getPoints(150)),
            new THREE.LineDashedMaterial({ color: 0xffffff, dashSize: 1, gapSize: 0.5, linewidth: 3 })
        );
        routeLine.computeLineDistances();
        mapGroup.add(routeLine);

        const car = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.6, 2.0), new THREE.MeshStandardMaterial({ color: 0xff0000 }));
        car.castShadow = true;
        mapGroup.add(car);

        // --- SCENE 3: THE 10-PAGE BOOK ---
        const bookGroup = new THREE.Group();
        bookGroup.visible = false;
        scene.add(bookGroup);
        
        const pages = [];
        function createPageTexture(pageNum, text) {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 1024;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#fff9f0'; ctx.fillRect(0, 0, 512, 1024); 
            ctx.fillStyle = '#4a0000'; 
            
            if(pageNum === 1) {
                 ctx.font = 'bold 50px serif'; ctx.textAlign = 'center';
                 ctx.fillText("Our Story", 256, 300);
                 ctx.font = 'italic 30px serif';
                 ctx.fillText("For Jess", 256, 400);
                 ctx.fillText("Happy Valentine's Day", 256, 500);
            } else {
                ctx.font = 'bold 40px serif'; ctx.textAlign = 'center';
                ctx.fillText(`Chapter ${pageNum-1}`, 256, 150);
                ctx.font = 'italic 30px serif';
                ctx.fillText(text, 256, 400);
            }
            return new THREE.CanvasTexture(canvas);
        }

        const bookContent = [
            "", 
            "Where it all began...", "The first time I saw you smile.", 
            "Every moment since has been better.", "Building our future, brick by brick.", 
            "Through thick and thin.", "You are my rock and my joy.", 
            "Beautiful inside and out.", "My favorite person in the world.", "I love you, forever."
        ];

        for(let i = 0; i < 10; i++) {
            const pivot = new THREE.Group();
            pivot.position.set(-1.5, 0, (10 - i) * 0.01); 
            const pageMat = new THREE.MeshStandardMaterial({ map: createPageTexture(i+1, bookContent[i]), side: THREE.DoubleSide });
            const pageMesh = new THREE.Mesh(new THREE.BoxGeometry(3, 4, 0.02), pageMat);
            pageMesh.position.set(1.5, 0, 0); 
            pageMesh.userData = { id: i, flipped: false };
            pivot.add(pageMesh);
            bookGroup.add(pivot);
            pages.push({ pivot: pivot, mesh: pageMesh });
        }
        const backCover = new THREE.Mesh(new THREE.BoxGeometry(3.2, 4.2, 0.05), new THREE.MeshStandardMaterial({ color: 0x8b0000 }));
        backCover.position.set(0,0,-0.1);
        bookGroup.add(backCover);

        // --- THE CINEMATIC ANIMATION SEQUENCE ---

        let appState = 'room'; 
        let mapProgress = 0;
        let flickerInterval;

        document.getElementById('startBtn').addEventListener('click', () => {
            const uiLayer = document.getElementById('ui-layer');
            uiLayer.style.opacity = 0;
            setTimeout(() => uiLayer.remove(), 1500); 

            const tl = gsap.timeline();

            // 1. Walk to the couch
            tl.to(camera.position, { 
                z: 2.5, y: 2.5, duration: 2, ease: "power2.inOut" 
            }, 0);

            // 2. Pick up the remote
            tl.to(remoteGroup.position, { 
                x: 0.5, y: 1.8, z: 1.5, duration: 1, ease: "back.in(1)"
            }, 1.5);
            tl.to(remoteGroup.rotation, { x: 0.5 }, 1.5);
            
            // "Click" and hide it
            tl.to(remoteGroup.scale, { x:0, y:0, z:0, duration: 0.2 }, 2.5);

            // 3. Flicker the TV
            tl.call(() => {
                let flickerCount = 0;
                flickerInterval = setInterval(() => {
                    flickerCtx.fillStyle = Math.random() > 0.5 ? '#ffffff' : '#333333';
                    flickerCtx.fillRect(0,0,512,256);
                    flickerTexture.needsUpdate = true;
                    flickerCount++;
                    
                    if(flickerCount > 15) { 
                        clearInterval(flickerInterval);
                        
                        // FAKE VIDEO SCREEN FOR LOCAL TESTING
                        flickerCtx.fillStyle = '#111111';
                        flickerCtx.fillRect(0,0,512,256);
                        flickerCtx.fillStyle = '#ff4d4d';
                        flickerCtx.font = 'bold 40px sans-serif';
                        flickerCtx.textAlign = 'center';
                        flickerCtx.fillText('Video plays perfectly', 256, 110);
                        flickerCtx.fillText('when uploaded to GitHub!', 256, 160);
                        flickerTexture.needsUpdate = true;
                        
                        startZoomSequence();
                    }
                }, 100);
            }, null, 2.7);
        });

        function startZoomSequence() {
            gsap.to(camera.position, {
                x: 0, y: 2.75, z: -3.8, // Zoom right to the TV screen!
                duration: 2.5,
                delay: 4, // Gives you 4 seconds to read the fake screen
                ease: "power3.inOut",
                onComplete: () => {
                    roomGroup.visible = false;
                    mapGroup.visible = true;
                    appState = 'map';
                    camera.position.set(-15, 25, 25); 
                    camera.lookAt(0, 0, 0);
                }
            });
        }

        window.addEventListener('pointerdown', (e) => {
            if(appState !== 'book') return;
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(pages.map(p => p.mesh));
            if(intersects.length > 0) {
                let clickedPage = pages.find(p => p.mesh === intersects[0].object);
                if(clickedPage) clickedPage.mesh.userData.flipped = !clickedPage.mesh.userData.flipped;
            }
        });

        function animate() {
            requestAnimationFrame(animate);

            if (appState === 'map') {
                mapProgress += 0.0015; 
                if (mapProgress >= 1) {
                    mapProgress = 1;
                    if(mapGroup.visible) {
                         mapGroup.visible = false;
                         bookGroup.visible = true;
                         appState = 'book';
                         camera.position.set(0, 1, 6);
                         camera.lookAt(0, 0, 0);
                         document.getElementById('instructions').style.display = 'block';
                    }
                } else {
                    const currentPos = routeCurve.getPoint(mapProgress);
                    car.position.copy(currentPos);
                    car.lookAt(routeCurve.getPoint(Math.min(mapProgress + 0.01, 1)));
                }
            }

            if (appState === 'book') {
                pages.forEach(p => {
                    const targetRot = p.mesh.userData.flipped ? -Math.PI * 0.9 : 0;
                    p.pivot.rotation.y += (targetRot - p.pivot.rotation.y) * 0.1;
                });
            }

            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
