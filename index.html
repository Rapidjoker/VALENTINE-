<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Our Love Story</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', Tahoma, sans-serif; }
        #webgl-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; }
        #css2d-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 2; pointer-events: none; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100vw; height: 100vh;
            display: flex; justify-content: center; align-items: center; z-index: 10;
            background: rgba(0,0,0,0.8); transition: opacity 1s ease;
        }
        
        button {
            padding: 20px 40px; font-size: 24px; font-weight: bold; background-color: #e63946;
            color: white; border: none; border-radius: 50px; cursor: pointer;
            box-shadow: 0 10px 20px rgba(230, 57, 70, 0.4); transition: transform 0.2s; pointer-events: auto;
        }
        button:hover { transform: scale(1.05); }

        .map-label {
            color: white; font-weight: bold; padding: 5px 10px; border-radius: 5px;
            font-size: 14px; text-shadow: 1px 1px 3px rgba(0,0,0,0.8); pointer-events: none;
        }
        .label-start { background: rgba(255, 215, 0, 0.3); border: 1px solid gold; color: gold; }
        .label-end { background: rgba(255, 105, 180, 0.3); border: 1px solid hotpink; color: hotpink; }
        
        #instructions {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            color: white; font-size: 18px; display: none; z-index: 5; pointer-events: none;
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="ui-layer">
        <button id="startBtn">Begin Our Valentine's Story</button>
    </div>
    <div id="instructions">Click the right side of the book to turn pages</div>
    
    <div id="webgl-container"></div>
    <div id="css2d-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        // --- GLOBAL SETUP ---
        const container = document.getElementById('webgl-container');
        const cssContainer = document.getElementById('css2d-container');
        
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 3, 7);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        const labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        cssContainer.appendChild(labelRenderer.domElement);

        const clock = new THREE.Clock();
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
        dirLight.position.set(5, 10, 5);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // --- SCENE 1: LIVING ROOM ---
        const roomGroup = new THREE.Group();
        scene.add(roomGroup);

        // Room geometry
        const floorMat = new THREE.MeshStandardMaterial({ color: 0x5c4033 });
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(10, 10), floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        roomGroup.add(floor);

        const wallMat = new THREE.MeshStandardMaterial({ color: 0xeeddcc });
        const backWall = new THREE.Mesh(new THREE.PlaneGeometry(10, 5), wallMat);
        backWall.position.set(0, 2.5, -5);
        roomGroup.add(backWall);

        // Furniture
        const couch = new THREE.Mesh(new THREE.BoxGeometry(3, 1.5, 1.5), new THREE.MeshStandardMaterial({ color: 0x2b2b2b }));
        couch.position.set(-1.5, 0.75, 1.5);
        roomGroup.add(couch);

        const table = new THREE.Mesh(new THREE.BoxGeometry(2, 0.5, 1), new THREE.MeshStandardMaterial({ color: 0x8b5a2b }));
        table.position.set(-1.0, 0.25, -0.5);
        roomGroup.add(table);

        const remote = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.05, 0.3), new THREE.MeshStandardMaterial({ color: 0x111111 }));
        remote.position.set(-1.0, 0.52, -0.5);
        roomGroup.add(remote);

        const tvCab = new THREE.Mesh(new THREE.BoxGeometry(4, 1, 1), new THREE.MeshStandardMaterial({ color: 0x333333 }));
        tvCab.position.set(0, 0.5, -4.5);
        roomGroup.add(tvCab);

        // Dynamic TV Screen
        const tvCanvas = document.createElement('canvas');
        tvCanvas.width = 512; tvCanvas.height = 256;
        const tvCtx = tvCanvas.getContext('2d');
        const tvTexture = new THREE.CanvasTexture(tvCanvas);
        
        const tvScreen = new THREE.Mesh(new THREE.PlaneGeometry(3.6, 2), new THREE.MeshBasicMaterial({ map: tvTexture }));
        tvScreen.position.set(0, 2.2, -4.4);
        roomGroup.add(tvScreen);

        // Character
        const charGroup = new THREE.Group();
        charGroup.position.set(-3, 1, 2.5); // Start pos
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 1.5), new THREE.MeshStandardMaterial({ color: 0x4a90e2 }));
        const head = new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshStandardMaterial({ color: 0xffddaa }));
        head.position.y = 1.0;
        charGroup.add(body, head);
        roomGroup.add(charGroup);

        // --- SCENE 2: MAP ---
        const mapGroup = new THREE.Group();
        mapGroup.visible = false;
        scene.add(mapGroup);

        const mapFloor = new THREE.Mesh(new THREE.PlaneGeometry(30, 30), new THREE.MeshStandardMaterial({ color: 0x223322 }));
        mapFloor.rotation.x = -Math.PI / 2;
        mapGroup.add(mapFloor);
        mapGroup.add(new THREE.GridHelper(30, 30, 0x445544, 0x334433));

        // Markers
        const startPos = new THREE.Vector3(-6, 0.2, -4);
        const endPos = new THREE.Vector3(7, 0.2, 5);

        const startMarker = new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshBasicMaterial({ color: 0xffd700 }));
        startMarker.position.copy(startPos);
        mapGroup.add(startMarker);
        
        const startDiv = document.createElement('div');
        startDiv.className = 'map-label label-start';
        startDiv.textContent = '10996 Rametsane';
        startMarker.add(new CSS2DObject(startDiv));

        const endMarker = new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshBasicMaterial({ color: 0xff69b4 }));
        endMarker.position.copy(endPos);
        mapGroup.add(endMarker);

        const endDiv = document.createElement('div');
        endDiv.className = 'map-label label-end';
        endDiv.textContent = '59866 Shorobe St';
        endMarker.add(new CSS2DObject(endDiv));

        
        
        // Route
        const routeCurve = new THREE.CatmullRomCurve3([
            startPos, new THREE.Vector3(-2, 0.2, -2), new THREE.Vector3(3, 0.2, 1), endPos
        ]);
        const routeLine = new THREE.Line(
            new THREE.BufferGeometry().setFromPoints(routeCurve.getPoints(100)),
            new THREE.LineDashedMaterial({ color: 0xffffff, dashSize: 0.5, gapSize: 0.2 })
        );
        routeLine.computeLineDistances();
        mapGroup.add(routeLine);

        // Car
        const car = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.3, 0.4), new THREE.MeshStandardMaterial({ color: 0xff0000 }));
        mapGroup.add(car);

        // --- SCENE 3: THE BOOK ---
        const bookGroup = new THREE.Group();
        bookGroup.visible = false;
        scene.add(bookGroup);
        
        const pages = [];
        const totalPages = 10;
        
        // Helper to generate canvas text textures
        function createPageTexture(pageNum) {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 1024;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#fff9f0'; ctx.fillRect(0, 0, 512, 1024);
            ctx.fillStyle = '#4a0000'; ctx.font = 'bold 40px serif';
            ctx.textAlign = 'center';
            ctx.fillText(`Chapter ${pageNum}`, 256, 150);
            ctx.font = 'italic 28px serif';
            const messages = [
                "Where it all began...", "Our first laugh.", "The way you smile.", 
                "Building our future.", "Every little moment.", "Through thick and thin.",
                "You are my rock.", "Beautiful inside & out.", "My favorite person.", "I love you, Jess."
            ];
            ctx.fillText(messages[pageNum-1], 256, 300);
            return new THREE.CanvasTexture(canvas);
        }

        for(let i = 0; i < totalPages; i++) {
            // Pivot group acts as the "hinge" of the book spine
            const pivot = new THREE.Group();
            pivot.position.set(-1.5, 0, (totalPages - i) * 0.02); // Stack pages slightly
            
            const pageMat = new THREE.MeshStandardMaterial({ 
                map: createPageTexture(i+1), side: THREE.DoubleSide 
            });
            const pageMesh = new THREE.Mesh(new THREE.BoxGeometry(3, 4, 0.01), pageMat);
            pageMesh.position.set(1.5, 0, 0); // Offset from pivot
            pageMesh.userData = { id: i, flipped: false };
            
            pivot.add(pageMesh);
            bookGroup.add(pivot);
            pages.push({ pivot: pivot, mesh: pageMesh });
        }
        bookGroup.position.set(0, 0, 0);

        // --- ANIMATION TIMELINE ENGINE ---
        let time = 0;
        let isRunning = false;
        
        // Initial TV Draw
        tvCtx.fillStyle = '#111'; tvCtx.fillRect(0,0,512,256);
        tvCtx.fillStyle = 'red'; tvCtx.font = '50px sans-serif';
        tvCtx.fillText('❤️', 230, 140);
        tvTexture.needsUpdate = true;

        document.getElementById('startBtn').addEventListener('click', () => {
            document.getElementById('ui-layer').style.opacity = '0';
            setTimeout(() => { document.getElementById('ui-layer').style.display = 'none'; }, 1000);
            clock.start();
            isRunning = true;
        });

        // Book Interaction logic
        window.addEventListener('pointerdown', (e) => {
            if(!bookGroup.visible) return;
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObjects(pages.map(p => p.mesh));
            if(intersects.length > 0) {
                // Find the topmost page clicked
                let clickedPage = pages.find(p => p.mesh === intersects[0].object);
                if(clickedPage) {
                    clickedPage.mesh.userData.flipped = !clickedPage.mesh.userData.flipped;
                }
            }
        });

        function animate() {
            requestAnimationFrame(animate);
            
            if (isRunning) {
                time += clock.getDelta();

                // Phase 1: Walk to couch (0-3s)
                if (time < 3) {
                    const progress = time / 3;
                    charGroup.position.lerpVectors(new THREE.Vector3(-3, 1, 2.5), new THREE.Vector3(-1.2, 1, 1.5), progress);
                } 
                // Phase 2: Sit down (3-3.5s)
                else if (time >= 3 && time < 3.5) {
                    charGroup.scale.y = 1 - ((time - 3) / 0.5) * 0.3; // scale down to 0.7
                }
                // Phase 3: Grab Remote (3.5-4.5s)
                else if (time >= 3.5 && time < 4.5) {
                    const prog = (time - 3.5) / 1;
                    remote.position.lerpVectors(new THREE.Vector3(-1.0, 0.52, -0.5), new THREE.Vector3(-1.0, 1.2, 1.8), prog);
                }
                // Phase 4: TV plays (4.5 - 9.5s)
                else if (time >= 4.5 && time < 9.5) {
                    // Flicker effect for first 0.5s
                    if(time < 5.0) {
                        tvCtx.fillStyle = Math.random() > 0.5 ? 'white' : 'black';
                        tvCtx.fillRect(0,0,512,256);
                    } else {
                        // Video loop
                        tvCtx.fillStyle = '#222'; tvCtx.fillRect(0,0,512,256);
                        tvCtx.fillStyle = 'white'; tvCtx.font = '40px sans-serif';
                        tvCtx.fillText('You & Me', 170, 100 + Math.sin(time*5)*10);
                        tvCtx.fillStyle = 'red';
                        tvCtx.fillText('Happy Valentine\'s', 100, 180);
                    }
                    tvTexture.needsUpdate = true;
                }
                // Phase 5: Camera Zoom (9.5 - 11.5s)
                else if (time >= 9.5 && time < 11.5) {
                    const prog = (time - 9.5) / 2;
                    camera.position.lerpVectors(new THREE.Vector3(0, 3, 7), new THREE.Vector3(0, 2.2, -3.5), prog);
                }
                // Phase 6: Switch to Map & Drive (11.5 - 19.5s)
                else if (time >= 11.5 && time < 19.5) {
                    if (roomGroup.visible) {
                        roomGroup.visible = false;
                        mapGroup.visible = true;
                        camera.position.set(0, 8, 12);
                        camera.lookAt(0,0,0);
                    }
                    const prog = (time - 11.5) / 8; // 8 second drive
                    const currentPos = routeCurve.getPoint(prog);
                    car.position.copy(currentPos);
                    
                    // Look ahead on the curve to steer
                    if(prog < 0.99) {
                        const nextPos = routeCurve.getPoint(prog + 0.01);
                        car.lookAt(nextPos);
                    }
                }
                // Phase 7: Switch to Book (19.5s+)
                else if (time >= 19.5) {
                    if (mapGroup.visible) {
                        mapGroup.visible = false;
                        bookGroup.visible = true;
                        camera.position.set(0, 0, 7);
                        camera.lookAt(0,0,0);
                        document.getElementById('instructions').style.display = 'block';
                    }
                    
                    // Handle smooth page flipping
                    pages.forEach(p => {
                        const targetRot = p.mesh.userData.flipped ? -Math.PI : 0;
                        p.pivot.rotation.y += (targetRot - p.pivot.rotation.y) * 0.1;
                    });
                }
            }

            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        // Handle resizing
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
