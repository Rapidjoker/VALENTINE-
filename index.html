<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>For Jess - Our Journey</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', Tahoma, sans-serif; touch-action: none; }
        #webgl-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; }
        
        /* Map labels hidden initially */
        #css2d-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 2; pointer-events: none; opacity: 0; transition: opacity 0.5s ease; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100vw; height: 100vh;
            display: flex; justify-content: center; align-items: center; z-index: 10;
            background: #000000; transition: opacity 1.5s ease; 
        }
        
        #transition-overlay {
            position: absolute; top: 0; left: 0; width: 100vw; height: 100vh;
            background: #2a0510; opacity: 0; pointer-events: none; z-index: 15;
        }

        button {
            padding: 20px 40px; font-size: 24px; font-weight: bold; background-color: #e63946;
            color: white; border: none; border-radius: 50px; cursor: pointer;
            box-shadow: 0 10px 20px rgba(230, 57, 70, 0.4); transition: transform 0.2s; pointer-events: auto;
        }
        button:hover { transform: scale(1.05); }

        .map-label {
            color: white; font-weight: bold; padding: 5px 10px; border-radius: 5px;
            font-size: 14px; text-shadow: 1px 1px 3px rgba(0,0,0,0.8); pointer-events: none;
            white-space: nowrap;
        }
        .label-start { background: rgba(255, 215, 0, 0.5); border: 2px solid gold; color: gold; }
        .label-end { background: rgba(255, 105, 180, 0.5); border: 2px solid hotpink; color: hotpink; }
        
        #drag-instruction {
            position: absolute; top: 80px; width: 100%; text-align: center;
            color: white; font-size: 18px; opacity: 0; z-index: 5; pointer-events: none;
            text-shadow: 1px 1px 3px black; transition: opacity 1s ease;
            font-weight: bold;
        }

        #instructions {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            color: white; font-size: 18px; display: none; z-index: 5; pointer-events: none;
            text-shadow: 1px 1px 2px black;
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/",
                "gsap": "https://unpkg.com/gsap@3.12.2/index.js"
            }
        }
    </script>
</head>
<body>
    
    <video id="tvVideo" src="video.mp4" playsinline webkit-playsinline muted loop style="position: absolute; width: 1px; height: 1px; opacity: 0;"></video>
    <audio id="tvAudio" src="song.mp3" loop style="display:none;"></audio>

    <div id="ui-layer">
        <button id="startBtn">Enter Our World</button>
    </div>
    <div id="transition-overlay"></div>
    <div id="drag-instruction">ðŸš— YOU are driving! <br> Drag screen to look around & see Jess</div>
    <div id="instructions">Click the right side of the book to turn pages</div>
    
    <div id="webgl-container"></div>
    <div id="css2d-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
        import gsap from 'gsap';

        const container = document.getElementById('webgl-container');
        const cssContainer = document.getElementById('css2d-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 10, 60); // Hides the edge of the world
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 4.5, 7); 

        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.BasicShadowMap;
        container.appendChild(renderer.domElement);

        const labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        cssContainer.appendChild(labelRenderer.domElement);

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(20, 40, 20);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        scene.add(dirLight);

        // --- SCENE 1: LIVING ROOM ---
        const roomGroup = new THREE.Group();
        scene.add(roomGroup);

        // Floor
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(30, 30), new THREE.MeshStandardMaterial({ color: 0x1da289 }));
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        roomGroup.add(floor);

        // Walls
        const wallMat = new THREE.MeshStandardMaterial({ color: 0xff91af }); 
        const backWall = new THREE.Mesh(new THREE.PlaneGeometry(30, 15), wallMat);
        backWall.position.set(0, 7.5, -8);
        roomGroup.add(backWall);
        const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(30, 15), wallMat);
        leftWall.rotation.y = Math.PI / 2; leftWall.position.set(-12, 7.5, 0); roomGroup.add(leftWall);
        const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(30, 15), wallMat);
        rightWall.rotation.y = -Math.PI / 2; rightWall.position.set(12, 7.5, 0); roomGroup.add(rightWall);

        // Furniture
        const rug = new THREE.Mesh(new THREE.CylinderGeometry(4, 4, 0.05, 32), new THREE.MeshStandardMaterial({ color: 0xc964af }));
        rug.scale.set(1, 1, 0.6); rug.position.set(0, 0.02, -1); roomGroup.add(rug);

        const couchMat = new THREE.MeshStandardMaterial({ color: 0xd2691e });
        const couchSeat = new THREE.Mesh(new THREE.BoxGeometry(6, 1, 2.5), couchMat);
        couchSeat.position.set(0, 0.5, 2.5);
        const couchBack = new THREE.Mesh(new THREE.BoxGeometry(6, 2, 0.5), couchMat);
        couchBack.position.set(0, 2, 3.5);
        roomGroup.add(couchSeat, couchBack);

        const table = new THREE.Mesh(new THREE.BoxGeometry(3, 1, 1.5), new THREE.MeshStandardMaterial({ color: 0xcd853f }));
        table.position.set(0, 0.5, -1.5); roomGroup.add(table);

        const tvStand = new THREE.Mesh(new THREE.BoxGeometry(4, 1.5, 2), new THREE.MeshStandardMaterial({ color: 0x784c98 }));
        tvStand.position.set(0, 0.75, -5.5); roomGroup.add(tvStand);

        const tvBox = new THREE.Mesh(new THREE.BoxGeometry(1.8, 3.2, 1.5), new THREE.MeshStandardMaterial({ color: 0x8a929e }));
        tvBox.position.set(0, 3.1, -5.5); roomGroup.add(tvBox);

        // Video Screen
        const flickerCanvas = document.createElement('canvas');
        flickerCanvas.width = 256; flickerCanvas.height = 512;
        const flickerCtx = flickerCanvas.getContext('2d');
        const flickerTexture = new THREE.CanvasTexture(flickerCanvas);
        flickerCtx.fillStyle = '#111111'; flickerCtx.fillRect(0, 0, 256, 512);

        const videoEl = document.getElementById('tvVideo');
        const audioEl = document.getElementById('tvAudio');
        const videoTexture = new THREE.VideoTexture(videoEl);

        const tvScreen = new THREE.Mesh(new THREE.PlaneGeometry(1.6, 3.0), new THREE.MeshBasicMaterial({ map: flickerTexture }));
        tvScreen.position.set(0, 3.1, -4.74); roomGroup.add(tvScreen);

        // --- SCENE 2: THE CITY (First Person) ---
        const mapGroup = new THREE.Group();
        mapGroup.visible = false;
        scene.add(mapGroup);

        // Infinite Grass Floor
        const grassGeo = new THREE.PlaneGeometry(300, 300);
        const grassMat = new THREE.MeshStandardMaterial({ color: 0x3b5e2b });
        const mapFloor = new THREE.Mesh(grassGeo, grassMat);
        mapFloor.rotation.x = -Math.PI / 2;
        mapFloor.receiveShadow = true;
        mapGroup.add(mapFloor);

        // The Road Curve
        const routePoints = [
            new THREE.Vector3(-40, 0.2, -40),
            new THREE.Vector3(-10, 0.2, -10),
            new THREE.Vector3(10, 0.2, 0),
            new THREE.Vector3(30, 0.2, 20),
            new THREE.Vector3(50, 0.2, 50)
        ];
        const routeCurve = new THREE.CatmullRomCurve3(routePoints);
        
        // Road Mesh
        const roadGeo = new THREE.TubeGeometry(routeCurve, 100, 3, 8, false);
        const roadMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
        const road = new THREE.Mesh(roadGeo, roadMat);
        road.scale.y = 0.02; 
        road.position.y = 0.05;
        road.receiveShadow = true;
        mapGroup.add(road);

        // --- CITY LIFE (Buildings, Trees, People) ---
        const cityLifeGroup = new THREE.Group();
        mapGroup.add(cityLifeGroup);

        const buildingMat = new THREE.MeshStandardMaterial({ color: 0x8a9ea8 });
        const treeMat = new THREE.MeshStandardMaterial({ color: 0x228b22 });
        const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5c4033 });
        const personMat = new THREE.MeshStandardMaterial({ color: 0xffa500 });

        for(let i=0; i<150; i++) {
            const x = (Math.random() - 0.5) * 120;
            const z = (Math.random() - 0.5) * 120;
            
            // Don't spawn on the road
            if(Math.abs(x - z) > 10) {
                const type = Math.random();
                
                if(type > 0.6) { // Building
                    const h = Math.random() * 15 + 5;
                    const b = new THREE.Mesh(new THREE.BoxGeometry(3, h, 3), buildingMat);
                    b.position.set(x, h/2, z);
                    b.castShadow = true;
                    cityLifeGroup.add(b);
                } else if (type > 0.3) { // Tree
                    const t = new THREE.Group();
                    const tr = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 2), trunkMat); tr.position.y = 1;
                    const l = new THREE.Mesh(new THREE.ConeGeometry(2, 4, 8), treeMat); l.position.y = 3;
                    t.add(tr, l);
                    t.position.set(x, 0, z);
                    cityLifeGroup.add(t);
                } else { // Person
                    const p = new THREE.Mesh(new THREE.CapsuleGeometry(0.3, 1, 4), personMat);
                    p.position.set(x, 0.8, z);
                    cityLifeGroup.add(p);
                }
            }
        }

        // Sellers/Stalls
        const stallColors = [0xff0000, 0x0000ff, 0xffff00];
        for(let i=0; i<6; i++) {
            const stall = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), new THREE.MeshStandardMaterial({ color: stallColors[i%3] }));
            stall.position.set(-20 + i*8, 1, -25 + i*8); // Along the road
            cityLifeGroup.add(stall);
        }

        // --- MOVING TRAFFIC ---
        const trafficCars = [];
        const trafficGeo = new THREE.BoxGeometry(2, 1, 4);
        const trafficMat = new THREE.MeshStandardMaterial({ color: 0xffffff }); // White cars
        
        for(let i=0; i<5; i++) {
            const tCar = new THREE.Mesh(trafficGeo, trafficMat);
            const offset = (i / 5);
            tCar.userData = { offset: offset, speed: 0.0005 + Math.random()*0.0005 };
            mapGroup.add(tCar);
            trafficCars.push(tCar);
        }

        // --- THE HERO CAR (First Person Setup) ---
        const carGroup = new THREE.Group();
        mapGroup.add(carGroup);

        // Car Body (Invisible from inside usually, but casts shadow)
        const carBody = new THREE.Mesh(new THREE.BoxGeometry(2.5, 1.5, 5), new THREE.MeshStandardMaterial({ color: 0x222222, visible: false }));
        carBody.position.y = 0.75;
        carGroup.add(carBody);

        // INTERIOR: Dashboard
        const dashboard = new THREE.Mesh(new THREE.BoxGeometry(2.4, 0.6, 1), new THREE.MeshStandardMaterial({ color: 0x111111 }));
        dashboard.position.set(0, 0.8, -0.8);
        carGroup.add(dashboard);

        // INTERIOR: Windshield Pillars (A-Pillars)
        const pillarL = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 1.5), new THREE.MeshStandardMaterial({ color: 0x333333 }));
        pillarL.position.set(-1.1, 1.5, -0.8); pillarL.rotation.x = -0.3; pillarL.rotation.z = -0.2;
        carGroup.add(pillarL);
        const pillarR = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 1.5), new THREE.MeshStandardMaterial({ color: 0x333333 }));
        pillarR.position.set(1.1, 1.5, -0.8); pillarR.rotation.x = -0.3; pillarR.rotation.z = 0.2;
        carGroup.add(pillarR);

        // INTERIOR: Steering Wheel (Right side - Botswana)
        const wheel = new THREE.Mesh(new THREE.TorusGeometry(0.35, 0.05, 8, 24), new THREE.MeshStandardMaterial({ color: 0x000000 }));
        wheel.position.set(0.6, 1.1, -0.4);
        wheel.rotation.x = -0.5;
        carGroup.add(wheel);

        // PASSENGER: Jess (Left side)
        const jessGroup = new THREE.Group();
        const jBody = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.8, 0.4), new THREE.MeshStandardMaterial({ color: 0xff69b4 })); // Pink top
        jBody.position.y = 0.4;
        const jHead = new THREE.Mesh(new THREE.SphereGeometry(0.25), new THREE.MeshStandardMaterial({ color: 0x8d5524 })); // Skin tone
        jHead.position.y = 1.0;
        const jHair = new THREE.Mesh(new THREE.SphereGeometry(0.28), new THREE.MeshStandardMaterial({ color: 0x000000 })); // Hair
        jHair.position.y = 1.05; jHair.scale.y = 0.8;
        jessGroup.add(jBody, jHead, jHair);
        jessGroup.position.set(-0.6, 0.2, 0.2); // Left seat
        carGroup.add(jessGroup);

        // Camera Pivot (Driver's Head Position)
        const cameraPivot = new THREE.Group();
        cameraPivot.position.set(0.6, 1.4, 0.3); // Driver seat, head height
        carGroup.add(cameraPivot);

        // --- INPUT HANDLING ---
        let isDragging = false;
        let prevX = 0, prevY = 0;
        let camYaw = 0, camPitch = 0;

        window.addEventListener('pointerdown', e => {
            isDragging = true; prevX = e.clientX; prevY = e.clientY;
            // Page turning logic for book
            if(appState === 'book') {
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(pages.map(p => p.mesh));
                if(intersects.length > 0) intersects[0].object.userData.flipped = !intersects[0].object.userData.flipped;
            }
        });
        window.addEventListener('pointermove', e => {
            if(isDragging && appState === 'map') {
                const dx = e.clientX - prevX;
                const dy = e.clientY - prevY;
                camYaw -= dx * 0.005;
                camPitch -= dy * 0.005;
                // Limit head movement
                camPitch = Math.max(-0.5, Math.min(0.5, camPitch));
                camYaw = Math.max(-1.5, Math.min(1.5, camYaw));
                cameraPivot.rotation.set(camPitch, camYaw, 0);
                prevX = e.clientX; prevY = e.clientY;
            }
        });
        window.addEventListener('pointerup', () => isDragging = false);


        // --- SCENE 4: BOOK & PARTICLES ---
        // (Keeping your previous working book & particle code logic)
        const bookGroup = new THREE.Group();
        bookGroup.visible = false;
        scene.add(bookGroup);
        // ... (Book generation logic remains same as previous working version for safety) ...
        // Re-creating book textures quickly:
        const pages = [];
        const bookChapters = [
            {t:"", b:""}, 
            {t:"Chapter 1", b:"From the very first moment..."}, 
            {t:"Chapter 2", b:"Every single day..."},
            {t:"Chapter 3", b:"I know sometimes..."},
            {t:"Chapter 4", b:"You are my safe place..."},
            {t:"Chapter 5", b:"Your heart of gold..."},
            {t:"Chapter 6", b:"My biggest cheerleader..."},
            {t:"Chapter 7", b:"You are a masterpiece..."},
            {t:"Chapter 8", b:"Building our future..."},
            {t:"Chapter 9", b:"I love you forever."}
        ];
        function createPage(idx, title, body) {
            const cvs = document.createElement('canvas'); cvs.width=256; cvs.height=512;
            const c = cvs.getContext('2d');
            c.fillStyle='#fdf6e3'; c.fillRect(0,0,256,512);
            c.fillStyle='#4a0000'; c.font='20px serif'; c.textAlign='center';
            if(idx===1){ c.font='30px serif'; c.fillText("Our Story",128,200); c.fillText("For Jess",128,250); }
            else { c.fillText(title,128,100); c.font='14px serif'; c.textAlign='left'; wrapText(c,body,20,200,210,20);}
            return new THREE.CanvasTexture(cvs);
        }
        function wrapText(c,t,x,y,mw,lh){const w=t.split(' ');let l='';for(let n=0;n<w.length;n++){const tl=l+w[n]+' ';if(c.measureText(tl).width>mw&&n>0){c.fillText(l,x,y);l=w[n]+' ';y+=lh}else{l=tl}}c.fillText(l,x,y)}

        for(let i=0; i<10; i++){
            const piv = new THREE.Group(); piv.position.set(-1.5,0,(10-i)*0.01);
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(3,4,0.02), new THREE.MeshStandardMaterial({map:createPage(i+1,bookChapters[i].t,bookChapters[i].b)}));
            mesh.position.set(1.5,0,0); mesh.userData={flipped:false};
            piv.add(mesh); bookGroup.add(piv); pages.push({mesh:mesh, pivot:piv});
        }
        const backCover = new THREE.Mesh(new THREE.BoxGeometry(3.2,4.2,0.05), new THREE.MeshStandardMaterial({color:0x5a0000}));
        backCover.position.z = -0.1; bookGroup.add(backCover);

        // Particles
        const partGeo = new THREE.BufferGeometry();
        const pPos = new Float32Array(450); // 150 particles * 3
        const pCol = new Float32Array(450);
        for(let i=0;i<150;i++){
            pPos[i*3]=(Math.random()-0.5)*20; pPos[i*3+1]=Math.random()*10; pPos[i*3+2]=(Math.random()-0.5)*10;
            pCol[i*3]=1; pCol[i*3+1]=0; pCol[i*3+2]=0; // Red
        }
        partGeo.setAttribute('position', new THREE.BufferAttribute(pPos,3));
        partGeo.setAttribute('color', new THREE.BufferAttribute(pCol,3));
        const particles = new THREE.Points(partGeo, new THREE.PointsMaterial({size:0.5, vertexColors:true}));
        particles.visible = false; scene.add(particles);


        // --- LOGIC ---
        let appState = 'room';
        let mapProgress = 0;
        let isTransitioning = false;

        document.getElementById('startBtn').addEventListener('click', () => {
            audioEl.volume = 0; audioEl.play().catch(()=>{}); videoEl.play().catch(()=>{});
            
            const tl = gsap.timeline();
            document.getElementById('ui-layer').style.opacity = 0;
            setTimeout(() => document.getElementById('ui-layer').remove(), 1500);

            tl.to(camera.position, {z:2.5, y:2.5, duration:2});
            tl.to(remoteGroup.position, {x:0.5, y:1.8, z:1.5, duration:1}, 1.5);
            tl.to(remoteGroup.scale, {x:0, y:0, z:0, duration:0.2}, 2.5);
            
            tl.call(() => {
                let f=0; 
                let int = setInterval(()=>{
                    flickerCtx.fillStyle=Math.random()>0.5?'#fff':'#333'; flickerCtx.fillRect(0,0,256,512); flickerTexture.needsUpdate=true;
                    f++;
                    if(f>15) {
                        clearInterval(int);
                        videoEl.currentTime=0; audioEl.volume=1;
                        tvScreen.material.map=videoTexture; tvScreen.material.needsUpdate=true;
                        setTimeout(startDrive, 15000);
                    }
                }, 100);
            }, null, 2.7);
        });

        function startDrive() {
            gsap.to(camera.position, {
                x: 0, y: 3.1, z: -4.0, duration: 2, ease: "power2.in",
                onComplete: () => {
                    roomGroup.visible = false;
                    mapGroup.visible = true;
                    cssContainer.style.opacity = 1;
                    document.getElementById('drag-instruction').style.opacity = 1;
                    
                    // Attach camera to driver's head
                    cameraPivot.add(camera);
                    camera.position.set(0,0,0);
                    camera.rotation.set(0,0,0);
                    
                    appState = 'map';
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);

            if(appState === 'map' && !isTransitioning) {
                mapProgress += 0.0005; // Driving speed
                if(mapProgress >= 1) {
                    mapProgress = 1;
                    isTransitioning = true;
                    // End transition logic
                    cssContainer.style.opacity = 0;
                    document.getElementById('drag-instruction').style.opacity = 0;
                    
                    const tl = gsap.timeline();
                    tl.to("#transition-overlay", {opacity:1, duration:1});
                    tl.call(()=>{
                        // Detach camera
                        scene.add(camera); camera.position.set(0,1,6); camera.rotation.set(0,0,0);
                        mapGroup.visible=false; bookGroup.visible=true; particles.visible=true;
                        scene.background.setHex(0x2a0510);
                        appState='book';
                        document.getElementById('instructions').style.display='block';
                    }, null, 1);
                    tl.to("#transition-overlay", {opacity:0, duration:1.5}, 1.5);
                } else {
                    const pos = routeCurve.getPoint(mapProgress);
                    const next = routeCurve.getPoint(Math.min(mapProgress+0.01, 1));
                    carGroup.position.copy(pos);
                    carGroup.lookAt(next);
                    
                    // Steer wheel
                    const dir = new THREE.Vector3().subVectors(next, pos).normalize();
                    wheel.rotation.z = dir.x * 2; 

                    // Move Traffic
                    trafficCars.forEach((c, idx) => {
                        // Stop light logic: stop every 5 seconds
                        const now = Date.now();
                        if (now % 8000 > 6000) return; // Stop

                        c.userData.offset += c.userData.speed;
                        if(c.userData.offset > 1) c.userData.offset = 0;
                        // Traffic moves on a slightly different curve (offset)
                        const tPos = routeCurve.getPoint(1 - c.userData.offset); // Opposite direction
                        c.position.set(tPos.x + 5, 0.5, tPos.z); // Offset lane
                        c.lookAt(routeCurve.getPoint(Math.max(0, 1 - c.userData.offset - 0.01)));
                    });
                }
            }

            if(appState === 'book') {
                const pAttr = particles.geometry.attributes.position;
                for(let i=1; i<pAttr.array.length; i+=3) {
                    pAttr.array[i] -= 0.05;
                    if(pAttr.array[i] < -5) pAttr.array[i] = 10;
                }
                pAttr.needsUpdate = true;
                
                pages.forEach(p => {
                    const t = p.mesh.userData.flipped ? -Math.PI*0.9 : 0;
                    p.pivot.rotation.y += (t - p.pivot.rotation.y)*0.1;
                });
            }

            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        });
        animate();
    </script>
</body>
</html>
