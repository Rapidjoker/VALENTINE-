<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>For Jess - Happy Valentine's Day</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', Tahoma, sans-serif; }
        #webgl-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; }
        #css2d-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 2; pointer-events: none; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100vw; height: 100vh;
            display: flex; justify-content: center; align-items: center; z-index: 10;
            background: rgba(0,0,0,0.9); transition: opacity 1s ease;
        }
        
        button {
            padding: 20px 40px; font-size: 24px; font-weight: bold; background-color: #e63946;
            color: white; border: none; border-radius: 50px; cursor: pointer;
            box-shadow: 0 10px 20px rgba(230, 57, 70, 0.4); transition: transform 0.2s; pointer-events: auto;
        }
        button:hover { transform: scale(1.05); }

        .map-label {
            color: white; font-weight: bold; padding: 5px 10px; border-radius: 5px;
            font-size: 14px; text-shadow: 1px 1px 3px rgba(0,0,0,0.8); pointer-events: none;
            white-space: nowrap;
        }
        .label-start { background: rgba(255, 215, 0, 0.5); border: 2px solid gold; color: gold; }
        .label-end { background: rgba(255, 105, 180, 0.5); border: 2px solid hotpink; color: hotpink; }
        
        #instructions {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            color: white; font-size: 18px; display: none; z-index: 5; pointer-events: none;
            text-shadow: 1px 1px 2px black;
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/",
                "gsap": "https://unpkg.com/gsap@3.12.2/index.js"
            }
        }
    </script>
</head>
<body>

    <video id="tvVideo" src="our-video.mp4" playsinline style="display:none;" loop></video>

    <div id="ui-layer">
        <button id="startBtn">Enter the Room</button>
    </div>
    <div id="instructions">Click the right side of the book to turn pages</div>
    
    <div id="webgl-container"></div>
    <div id="css2d-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
        import gsap from 'gsap';

        // --- GLOBAL SETUP ---
        const container = document.getElementById('webgl-container');
        const cssContainer = document.getElementById('css2d-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        
        // Start camera further back for the "walk up" effect
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 10); 

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);

        const labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        cssContainer.appendChild(labelRenderer.domElement);

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const textureLoader = new THREE.TextureLoader();

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);

        // --- SCENE 1: SIMPSONS ROOM (2.5D Setup) ---
        const roomGroup = new THREE.Group();
        scene.add(roomGroup);

        // 1. The Backdrop (Simpsons Image)
        // We use a huge plane right in front of the camera to act as the environment
        const roomTexture = textureLoader.load('image_28.png'); // USING YOUR UPLOADED IMAGE
        // Adjust aspect ratio to match image roughly (4:3)
        const roomGeo = new THREE.PlaneGeometry(16, 12); 
        const roomMat = new THREE.MeshBasicMaterial({ map: roomTexture, side: THREE.DoubleSide });
        const roomBackdrop = new THREE.Mesh(roomGeo, roomMat);
        roomBackdrop.position.set(0, 2, -5); // Positioned back in space
        roomGroup.add(roomBackdrop);

        // 2. The 3D Remote
        const remote = new THREE.Mesh(
            new THREE.BoxGeometry(0.2, 0.05, 0.5), 
            new THREE.MeshStandardMaterial({ color: 0x222222 })
        );
        // Position it to match where the table is in the drawing
        remote.position.set(-1.5, 0.8, -2); 
        remote.rotation.y = -0.2;
        roomGroup.add(remote);

        // 3. The TV Screen (Flicker & Video)
        // Canvas for static flicker effect
        const flickerCanvas = document.createElement('canvas');
        flickerCanvas.width = 256; flickerCanvas.height = 256;
        const flickerCtx = flickerCanvas.getContext('2d');
        const flickerTexture = new THREE.CanvasTexture(flickerCanvas);
        
        // Video Texture for real video
        const videoEl = document.getElementById('tvVideo');
        const videoTexture = new THREE.VideoTexture(videoEl);

        // The 3D mesh that sits precisely over the drawn TV
        const tvScreen = new THREE.Mesh(
            new THREE.PlaneGeometry(1.8, 1.4), 
            new THREE.MeshBasicMaterial({ map: flickerTexture }) // Start with flicker texture
        );
        // Coordinates tuned to match the TV position in image_28.png
        tvScreen.position.set(1.65, 0.95, -4.9); 
        roomGroup.add(tvScreen);

        // --- SCENE 2: THE MAP (Gaborone) ---
        const mapGroup = new THREE.Group();
        mapGroup.visible = false;
        scene.add(mapGroup);

        const mapFloor = new THREE.Mesh(new THREE.PlaneGeometry(50, 50), new THREE.MeshStandardMaterial({ color: 0x1b261b }));
        mapFloor.rotation.x = -Math.PI / 2;
        mapGroup.add(mapFloor);
        mapGroup.add(new THREE.GridHelper(50, 50, 0x334433, 0x223322));

        const startPos = new THREE.Vector3(-10, 0.5, -8);
        const endPos = new THREE.Vector3(12, 0.5, 8);

        // Markers & Labels
        const startMarker = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshBasicMaterial({ color: 0xffd700 }));
        startMarker.position.copy(startPos);
        mapGroup.add(startMarker);
        const startDiv = document.createElement('div'); startDiv.className = 'map-label label-start'; startDiv.textContent = '10996 Rametsane';
        startMarker.add(new CSS2DObject(startDiv));

        const endMarker = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshBasicMaterial({ color: 0xff69b4 }));
        endMarker.position.copy(endPos);
        mapGroup.add(endMarker);
        const endDiv = document.createElement('div'); endDiv.className = 'map-label label-end'; endDiv.textContent = '59866 Shorobe St, Block 7';
        endMarker.add(new CSS2DObject(endDiv));

        // The Route
        const routeCurve = new THREE.CatmullRomCurve3([
            startPos, new THREE.Vector3(-4, 0.5, -4), new THREE.Vector3(2, 0.5, 0), new THREE.Vector3(8, 0.5, 4), endPos
        ]);
        const routeLine = new THREE.Line(
            new THREE.BufferGeometry().setFromPoints(routeCurve.getPoints(150)),
            new THREE.LineDashedMaterial({ color: 0xffffff, dashSize: 1, gapSize: 0.5, linewidth: 2 })
        );
        routeLine.computeLineDistances();
        mapGroup.add(routeLine);

        // The Car
        const car = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.4, 1.2), new THREE.MeshStandardMaterial({ color: 0xff0000 }));
        mapGroup.add(car);

        // --- SCENE 3: THE 10-PAGE BOOK ---
        const bookGroup = new THREE.Group();
        bookGroup.visible = false;
        scene.add(bookGroup);
        
        const pages = [];
        // Helper to generate canvas text textures
        function createPageTexture(pageNum, text) {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 1024;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#fff9f0'; ctx.fillRect(0, 0, 512, 1024); // Paper color
            ctx.fillStyle = '#4a0000'; 
            
            if(pageNum === 1) {
                 ctx.font = 'bold 50px serif'; ctx.textAlign = 'center';
                 ctx.fillText("Our Story", 256, 300);
                 ctx.font = 'italic 30px serif';
                 ctx.fillText("For Jess", 256, 400);
                 ctx.fillText("Happy Valentine's Day", 256, 500);
            } else {
                ctx.font = 'bold 40px serif'; ctx.textAlign = 'center';
                ctx.fillText(`Chapter ${pageNum-1}`, 256, 150);
                ctx.font = 'italic 30px serif';
                ctx.fillText(text, 256, 400);
            }
            return new THREE.CanvasTexture(canvas);
        }

        const bookContent = [
            "", // Cover page handled separately
            "Where it all began...", "The first time I saw you smile.", 
            "Every moment since has been better.", "Building our future, brick by brick.", 
            "Through thick and thin.", "You are my rock and my joy.", 
            "Beautiful inside and out.", "My favorite person in the world.", "I love you, forever."
        ];

        for(let i = 0; i < 10; i++) {
            const pivot = new THREE.Group();
            pivot.position.set(-1.5, 0, (10 - i) * 0.01); 
            const pageMat = new THREE.MeshStandardMaterial({ map: createPageTexture(i+1, bookContent[i]), side: THREE.DoubleSide });
            const pageMesh = new THREE.Mesh(new THREE.BoxGeometry(3, 4, 0.02), pageMat);
            pageMesh.position.set(1.5, 0, 0); 
            pageMesh.userData = { id: i, flipped: false };
            pivot.add(pageMesh);
            bookGroup.add(pivot);
            pages.push({ pivot: pivot, mesh: pageMesh });
        }
        // Add a back cover
        const backCover = new THREE.Mesh(new THREE.BoxGeometry(3.2, 4.2, 0.05), new THREE.MeshStandardMaterial({ color: 0x8b0000 }));
        backCover.position.set(0,0,-0.1);
        bookGroup.add(backCover);

        // --- THE CINEMATIC ANIMATION SEQUENCE ---

        let appState = 'room'; // room, map, book
        let mapProgress = 0;
        let flickerInterval;

        // 1. Start the "Walk" Sequence
        document.getElementById('startBtn').addEventListener('click', () => {
            document.getElementById('ui-layer').style.opacity = 0;
            setTimeout(() => document.getElementById('ui-layer').remove(), 1000);

            const tl = gsap.timeline();

            // "Walk" to the couch (move camera)
            tl.to(camera.position, { 
                z: 3, y: 1.5, duration: 3, ease: "power2.inOut" 
            }, 0);

            // "Pick up" the remote (float it to camera and hide)
            tl.to(remote.position, { 
                x: 0, y: 1, z: 2, duration: 1.5, ease: "back.in(1)"
            }, 1.5);
            tl.to(remote.scale, { x:0, y:0, z:0, duration: 0.2 }, 2.9);

            // Turn on TV (Flicker sequence)
            tl.call(() => {
                let flickerCount = 0;
                flickerInterval = setInterval(() => {
                    flickerCtx.fillStyle = Math.random() > 0.5 ? '#ffffff' : '#333333';
                    flickerCtx.fillRect(0,0,256,256);
                    flickerTexture.needsUpdate = true;
                    flickerCount++;
                    if(flickerCount > 15) { // Stop flickering, play video
                        clearInterval(flickerInterval);
                        tvScreen.material.map = videoTexture;
                        tvScreen.material.needsUpdate = true;
                        videoEl.play();
                        startZoomSequence();
                    }
                }, 100);
            }, null, 3);
        });

        function startZoomSequence() {
            // Wait 4 seconds for video to play, then zoom exactly into the TV screen
            gsap.to(camera.position, {
                x: 1.65, y: 0.95, z: -4.0, // Target TV coordinates
                duration: 2.5,
                delay: 4,
                ease: "power3.inOut",
                onComplete: () => {
                    // Transition to Map
                    roomGroup.visible = false;
                    mapGroup.visible = true;
                    appState = 'map';
                    camera.position.set(0, 15, 20); // Bird's eye view for map
                    camera.lookAt(0, 0, 0);
                }
            });
        }

        // Book page turning interaction
        window.addEventListener('pointerdown', (e) => {
            if(appState !== 'book') return;
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(pages.map(p => p.mesh));
            if(intersects.length > 0) {
                let clickedPage = pages.find(p => p.mesh === intersects[0].object);
                if(clickedPage) clickedPage.mesh.userData.flipped = !clickedPage.mesh.userData.flipped;
            }
        });

        function animate() {
            requestAnimationFrame(animate);

            if (appState === 'map') {
                mapProgress += 0.0015; // Speed of car
                if (mapProgress >= 1) {
                    mapProgress = 1;
                    // Transition to Book
                    if(mapGroup.visible) {
                         mapGroup.visible = false;
                         bookGroup.visible = true;
                         appState = 'book';
                         camera.position.set(0, 1, 6);
                         camera.lookAt(0, 0, 0);
                         document.getElementById('instructions').style.display = 'block';
                    }
                } else {
                    const currentPos = routeCurve.getPoint(mapProgress);
                    car.position.copy(currentPos);
                    car.lookAt(routeCurve.getPoint(Math.min(mapProgress + 0.01, 1)));
                }
            }

            if (appState === 'book') {
                // Smooth page turning logic
                pages.forEach(p => {
                    const targetRot = p.mesh.userData.flipped ? -Math.PI * 0.9 : 0;
                    p.pivot.rotation.y += (targetRot - p.pivot.rotation.y) * 0.1;
                });
            }

            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
